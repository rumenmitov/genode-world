diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/cmd/go/internal/bug/bug.go gcc/libgo/go/cmd/go/internal/bug/bug.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/cmd/go/internal/bug/bug.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/cmd/go/internal/bug/bug.go	2021-04-12 17:01:41.714891894 +0300
@@ -96,7 +96,7 @@
 		printCmdOut(w, "uname -sr: ", "uname", "-sr")
 		printCmdOut(w, "", "lsb_release", "-a")
 		printGlibcVersion(w)
-	case "openbsd", "netbsd", "freebsd", "dragonfly":
+	case "openbsd", "netbsd", "freebsd", "dragonfly", "inno":
 		printCmdOut(w, "uname -v: ", "uname", "-v")
 	case "solaris":
 		out, err := ioutil.ReadFile("/etc/release")
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/os/executable_procfs.go gcc/libgo/go/os/executable_procfs.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/os/executable_procfs.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/os/executable_procfs.go	2021-04-12 17:01:41.727892036 +0300
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build linux netbsd dragonfly nacl
+// +build linux netbsd dragonfly nacl inno
 
 package os
 
@@ -19,7 +19,7 @@
 	switch runtime.GOOS {
 	default:
 		return "", errors.New("Executable not implemented for " + runtime.GOOS)
-	case "linux", "android":
+	case "linux", "android", "inno":
 		procfn = "/proc/self/exe"
 	case "netbsd":
 		procfn = "/proc/curproc/exe"
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/mem_gccgo.go gcc/libgo/go/runtime/mem_gccgo.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/mem_gccgo.go	2018-01-09 04:23:08.000000000 +0300
+++ gcc/libgo/go/runtime/mem_gccgo.go	2021-04-12 17:01:41.737892146 +0300
@@ -15,10 +15,10 @@
 //go:linkname sysAlloc runtime.sysAlloc
 //go:linkname sysFree runtime.sysFree
 
-//extern mmap
+//extern anon_mmap
 func sysMmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uintptr) unsafe.Pointer
 
-//extern munmap
+//extern anon_munmap
 func munmap(addr unsafe.Pointer, length uintptr) int32
 
 //extern mincore
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/os_gccgo.go gcc/libgo/go/runtime/os_gccgo.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/os_gccgo.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/runtime/os_gccgo.go	2021-04-12 17:01:41.732892091 +0300
@@ -45,8 +45,10 @@
 		extendRandom(r, n)
 		return
 	}
-	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
-	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
-	closefd(fd)
+	//fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
+	//n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
+	//closefd(fd)
+	// FIXME there is no /dev/urandom in genode
+	n := uintptr(unsafe.Pointer(&r[0]))
 	extendRandom(r, int(n))
 }
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_bsd.go gcc/libgo/go/syscall/exec_bsd.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_bsd.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/syscall/exec_bsd.go	2021-04-12 17:01:41.733892102 +0300
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build aix darwin dragonfly freebsd netbsd openbsd solaris
+// +build aix darwin dragonfly freebsd netbsd openbsd solaris inno
 
 package syscall
 
@@ -81,12 +81,13 @@
 	runtime_AfterForkInChild()
 
 	// Enable tracing if requested.
-	if sys.Ptrace {
-		err1 = raw_ptrace(_PTRACE_TRACEME, 0, nil, nil)
-		if err1 != 0 {
-			goto childerror
-		}
-	}
+	// FIXME: no ptrace in genode
+	//if sys.Ptrace {
+	//	err1 = raw_ptrace(_PTRACE_TRACEME, 0, nil, nil)
+	//	if err1 != 0 {
+	//		goto childerror
+	//	}
+	//}
 
 	// Session ID
 	if sys.Setsid {
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-caller.c gcc/libgo/runtime/go-caller.c
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-caller.c	2018-02-22 21:52:33.000000000 +0300
+++ gcc/libgo/runtime/go-caller.c	2021-04-12 17:01:41.736892135 +0300
@@ -116,7 +116,7 @@
 	 argv[0] (http://gcc.gnu.org/PR61895).  It would be nice to
 	 have a better check for whether this file is the real
 	 executable.  */
-      if (stat (filename, &s) < 0 || s.st_size < 1024)
+      if ((filename && stat (filename, &s) < 0) || s.st_size < 1024)
 	filename = NULL;
 
       back_state = backtrace_create_state (filename, 1, error_callback, NULL);
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-setenv.c gcc/libgo/runtime/go-setenv.c
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-setenv.c	2016-11-18 19:03:13.000000000 +0300
+++ gcc/libgo/runtime/go-setenv.c	2021-04-12 17:01:41.736892135 +0300
@@ -59,8 +59,9 @@
 
 #else /* !defined(HAVE_SETENV) */
 
-  len = k.len + v.len + 2;
+  { int len = k.len + v.len + 2;
   kn = malloc (len);
+  }
   if (kn == NULL)
     runtime_throw ("out of malloc memory");
   __builtin_memcpy (kn, ks, k.len);
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/proc.c gcc/libgo/runtime/proc.c
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/proc.c	2018-02-02 03:16:43.000000000 +0300
+++ gcc/libgo/runtime/proc.c	2021-04-12 17:01:41.737892146 +0300
@@ -51,7 +51,7 @@
 #if defined(USING_SPLIT_STACK) && defined(LINKER_SUPPORTS_SPLIT_STACK)
 # define StackMin PTHREAD_STACK_MIN
 #else
-# define StackMin ((sizeof(char *) < 8) ? 2 * 1024 * 1024 : 4 * 1024 * 1024)
+# define StackMin ((sizeof(char *) < 8) ? 2 * 1024 * 1024 : 1 * 1024 * 1024 - 4096*3)
 #endif
 
 uintptr runtime_stacks_sys;
@@ -609,6 +609,7 @@
 	getcontext(uc);
 	uc->uc_stack.ss_sp = sp;
 	uc->uc_stack.ss_size = (size_t)spsize;
+	uc->uc_mcontext.mc_len = sizeof(mcontext_t);
 	makecontext(uc, kickoff, 0);
 }
 
@@ -753,7 +754,8 @@
                 // 32-bit mode, the Go allocation space is all of
                 // memory anyhow.
 		if(sizeof(void*) == 8) {
-			void *p = runtime_sysAlloc(stacksize, &getMemstats()->stacks_sys);
+			//void *p = runtime_sysAlloc(stacksize, &getMemstats()->stacks_sys);
+			void *p = alloc_secondary_stack("goapp", stacksize); // no stat!
 			if(p == nil)
 				runtime_throw("runtime: cannot allocate memory for goroutine stack");
 			*ret_stack = (byte*)p;
@@ -770,6 +772,7 @@
 	return newg;
 }
 
+void free_secondary_stack( void *);
 void stackfree(G*)
   __asm__(GOSYM_PREFIX "runtime.stackfree");
 
@@ -786,7 +789,8 @@
   // using garbage collected memory.
   if (gp->gcstacksize != 0) {
     if (sizeof(void*) == 8) {
-      runtime_sysFree(gp->gcinitialsp, gp->gcstacksize, &getMemstats()->stacks_sys);
+      //runtime_sysFree(gp->gcinitialsp, gp->gcstacksize, &getMemstats()->stacks_sys);
+	  free_secondary_stack(gp->gcinitialsp);
     }
     gp->gcinitialsp = nil;
     gp->gcstacksize = 0;
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/thread.c gcc/libgo/runtime/thread.c
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/thread.c	2013-07-16 10:54:42.000000000 +0400
+++ gcc/libgo/runtime/thread.c	2021-04-12 17:01:41.737892146 +0300
@@ -148,7 +148,7 @@
 	// Not an exact science: use size of binary plus
 	// some room for thread stacks.
 	used = (64<<20);
-	if(used >= rl.rlim_cur)
+	if(used >= (uintptr)rl.rlim_cur)
 		return 0;
 
 	// If there's not at least 16 MB left, we're probably
