diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/cmd/go/internal/bug/bug.go gcc/libgo/go/cmd/go/internal/bug/bug.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/cmd/go/internal/bug/bug.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/cmd/go/internal/bug/bug.go	2021-04-12 17:01:41.714891894 +0300
@@ -96,7 +96,7 @@
 		printCmdOut(w, "uname -sr: ", "uname", "-sr")
 		printCmdOut(w, "", "lsb_release", "-a")
 		printGlibcVersion(w)
-	case "openbsd", "netbsd", "freebsd", "dragonfly":
+	case "openbsd", "netbsd", "freebsd", "dragonfly", "inno":
 		printCmdOut(w, "uname -v: ", "uname", "-v")
 	case "solaris":
 		out, err := ioutil.ReadFile("/etc/release")
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/os/executable_procfs.go gcc/libgo/go/os/executable_procfs.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/os/executable_procfs.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/os/executable_procfs.go	2021-04-12 17:01:41.727892036 +0300
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build hurd linux netbsd dragonfly js,wasm
+// +build hurd linux netbsd dragonfly js,wasm inno
 
 package os
 
@@ -19,7 +19,7 @@
 	switch runtime.GOOS {
 	default:
 		return "", errors.New("Executable not implemented for " + runtime.GOOS)
-	case "hurd", "linux", "android":
+	case "hurd", "linux", "android", "inno":
 		procfn = "/proc/self/exe"
 	case "netbsd":
 		procfn = "/proc/curproc/exe"
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/mem_gccgo.go gcc/libgo/go/runtime/mem_gccgo.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/mem_gccgo.go	2018-01-09 04:23:08.000000000 +0300
+++ gcc/libgo/go/runtime/mem_gccgo.go	2021-04-12 17:01:41.737892146 +0300
@@ -15,10 +15,10 @@
 //go:linkname sysAlloc runtime.sysAlloc
 //go:linkname sysFree runtime.sysFree
 
-//extern mmap
+//extern anon_mmap
 func sysMmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uintptr) unsafe.Pointer
 
-//extern munmap
+//extern anon_munmap
 func munmap(addr unsafe.Pointer, length uintptr) int32
 
 //extern mincore
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/os_gccgo.go gcc/libgo/go/runtime/os_gccgo.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/runtime/os_gccgo.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/runtime/os_gccgo.go	2021-04-12 17:01:41.732892091 +0300
@@ -45,8 +45,10 @@
 		extendRandom(r, n)
 		return
 	}
-	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
-	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
-	closefd(fd)
+	//fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
+	//n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
+	//closefd(fd)
+	// FIXME there is no /dev/urandom in genode
+	n := uintptr(unsafe.Pointer(&r[0]))
 	extendRandom(r, int(n))
 }
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_bsd.go gcc/libgo/go/syscall/exec_bsd.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_bsd.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/syscall/exec_bsd.go	2021-04-12 17:01:41.733892102 +0300
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build aix darwin dragonfly freebsd hurd netbsd openbsd solaris
+// +build aix darwin dragonfly freebsd hurd netbsd openbsd solaris inno
 
 package syscall
 
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-setenv.c gcc/libgo/runtime/go-setenv.c
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/runtime/go-setenv.c	2016-11-18 19:03:13.000000000 +0300
+++ gcc/libgo/runtime/go-setenv.c	2021-04-12 17:01:41.736892135 +0300
@@ -59,8 +59,9 @@
 
 #else /* !defined(HAVE_SETENV) */
 
-  len = k.len + v.len + 2;
+  { int len = k.len + v.len + 2;
   kn = malloc (len);
+  }
   if (kn == NULL)
     runtime_throw ("out of malloc memory");
   __builtin_memcpy (kn, ks, k.len);
diff -NaurwB gcc.libgobase/libgo/runtime/proc.c gcc.libgomod/libgo/runtime/proc.c
--- gcc.libgobase/libgo/runtime/proc.c	2021-06-08 12:14:11.381349797 +0300
+++ gcc.libgomod/libgo/runtime/proc.c	2021-06-19 20:50:50.181777480 +0300
@@ -19,6 +19,8 @@
 #include "arch.h"
 #include "defs.h"
 
+#include <alloc_secondary_stack.h>
+
 #ifdef USING_SPLIT_STACK
 
 /* FIXME: These are not declared anywhere.  */
@@ -50,7 +52,7 @@
 #if defined(USING_SPLIT_STACK) && defined(LINKER_SUPPORTS_SPLIT_STACK)
 # define StackMin PTHREAD_STACK_MIN
 #else
-# define StackMin ((sizeof(char *) < 8) ? 2 * 1024 * 1024 : 4 * 1024 * 1024)
+# define StackMin ((sizeof(char *) < 8) ? 2 * 1024 * 1024 : 1 * 1024 * 1024 - 4096*3)
 #endif
 
 uintptr runtime_stacks_sys;
@@ -64,7 +66,8 @@
 #define __thread
 #endif
 
-__thread G *g __asm__(GOSYM_PREFIX "runtime.g");
+static __thread G *g;
+/*__thread G *g __asm__(GOSYM_PREFIX "runtime.g"); gcc 10.3 bug - this string generates wrong asm code */
 
 #ifndef SETCONTEXT_CLOBBERS_TLS
 
@@ -774,6 +778,21 @@
 	reentersyscallblock(pc, sp);
 }
 
+// Allocate a new M to be used as stack later in pthread_create
+// for genode thread stack should be allocated from pre-defined place for myself() works correctly
+// other places where we use for stack code like
+// {
+// 	void *v;
+// 	g->gcnextsp = (uintptr)(&v);
+// }
+// should work because it will be performed in thread context where stack already was correctly
+// setup for pre-defined set of addresses allowed for thread stacks and myself() check will works
+M *runtime_newmalloc(void) __asm__(GOSYM_PREFIX "runtime.newmalloc");
+
+M *runtime_newmalloc(void)
+{
+	return (M *)alloc_secondary_stack("goappM", sizeof(M));
+}
 // Allocate a new g, with a stack big enough for stacksize bytes.
 G*
 runtime_malg(bool allocatestack, bool signalstack, byte** ret_stack, uintptr* ret_stacksize)
@@ -819,7 +838,8 @@
                 // 32-bit mode, the Go allocation space is all of
                 // memory anyhow.
 		if(sizeof(void*) == 8) {
-			void *p = runtime_sysAlloc(stacksize, &getMemstats()->stacks_sys);
+			//void *p = runtime_sysAlloc(stacksize, &getMemstats()->stacks_sys);
+			void *p = alloc_secondary_stack("goapp", stacksize); // no stat!
 			if(p == nil)
 				runtime_throw("runtime: cannot allocate memory for goroutine stack");
 			*ret_stack = (byte*)p;
@@ -836,6 +856,7 @@
 	return newg;
 }
 
+void free_secondary_stack( void *);
 void stackfree(G*)
   __asm__(GOSYM_PREFIX "runtime.stackfree");
 
@@ -852,7 +873,8 @@
   // using garbage collected memory.
   if (gp->gcstacksize != 0) {
     if (sizeof(void*) == 8) {
-      runtime_sysFree(gp->gcinitialsp, gp->gcstacksize, &getMemstats()->stacks_sys);
+      //runtime_sysFree(gp->gcinitialsp, gp->gcstacksize, &getMemstats()->stacks_sys);
+	  free_secondary_stack(gp->gcinitialsp);
     }
     gp->gcinitialsp = nil;
     gp->gcstacksize = 0;
diff -NaurwB gcc.libgobase/libgo/go/internal/poll/fd_poll_runtime.go gcc.libgomod/libgo/go/internal/poll/fd_poll_runtime.go
--- gcc.libgobase/libgo/go/internal/poll/fd_poll_runtime.go	2021-06-08 12:14:11.516350478 +0300
+++ gcc.libgomod/libgo/go/internal/poll/fd_poll_runtime.go	2021-06-08 17:08:06.225937928 +0300
@@ -42,7 +42,7 @@
 			runtime_pollUnblock(ctx)
 			runtime_pollClose(ctx)
 		}
-		return errnoErr(syscall.Errno(errno))
+		return syscall.Errno(errno)
 	}
 	pd.runtimeCtx = ctx
 	return nil
diff -NaurwB gcc.libgobase/libgo/go/runtime/malloc.go gcc.libgomod/libgo/go/runtime/malloc.go
--- gcc.libgobase/libgo/go/runtime/malloc.go	2021-06-08 12:14:11.555350675 +0300
+++ gcc.libgomod/libgo/go/runtime/malloc.go	2021-06-16 17:19:11.751114074 +0300
@@ -257,7 +260,8 @@
 	// logHeapArenaBytes is log_2 of heapArenaBytes. For clarity,
 	// prefer using heapArenaBytes where possible (we need the
 	// constant to compute some other constants).
-	logHeapArenaBytes = (6+20)*(_64bit*(1-sys.GoosWindows)*(1-sys.GoarchWasm)) + (2+20)*(_64bit*sys.GoosWindows) + (2+20)*(1-_64bit) + (2+20)*sys.GoarchWasm
+	// logHeapArenaBytes = (6+20)*(_64bit*(1-sys.GoosWindows)*(1-sys.GoarchWasm-sys.GoosInno)) + (2+20)*(_64bit*sys.GoosWindows) + (2+20)*(1-_64bit) + (2+20)*(sys.GoarchWasm+sys.GoosInno)
+	logHeapArenaBytes = 26
 
 	// heapArenaBitmapBytes is the size of each heap arena's bitmap.
 	heapArenaBitmapBytes = heapArenaBytes / (sys.PtrSize * 8 / 2)
diff -NaurwB contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_unix.go gcc/libgo/go/syscall/exec_unix.go
--- contrib/gcc-3cade18cf9defeefa714aa91de3b157fbad4aa18/src/noux-pkg/gcc/libgo/go/syscall/exec_unix.go	2017-09-14 20:11:35.000000000 +0300
+++ gcc/libgo/go/syscall/exec_unix.go	2021-04-12 17:01:41.733892102 +0300
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-// +build aix darwin dragonfly freebsd hurd linux netbsd openbsd solaris
+// +build aix darwin dragonfly freebsd hurd linux netbsd openbsd solaris inno
 
 // Fork, exec, wait, etc.
 
@@ -328,7 +328,7 @@
 	runtime_BeforeExec()
 
 	var err1 error
-	if runtime.GOOS == "solaris" || runtime.GOOS == "illumos" || runtime.GOOS == "aix" || runtime.GOOS == "hurd" {
+	if runtime.GOOS == "solaris" || runtime.GOOS == "illumos" || runtime.GOOS == "aix" || runtime.GOOS == "hurd" || runtime.GOOS == "inno" {
 		// RawSyscall should never be used on Solaris or AIX.
 		err1 = raw_execve(argv0p, &argvp[0], &envvp[0])
 	} else if runtime.GOOS == "darwin" {
diff -NaurwB gcc.libgobase/libgo/runtime/runtime.h gcc.libgomod/libgo/runtime/runtime.h
--- gcc.libgobase/libgo/runtime/runtime.h	2021-06-08 12:14:11.374349761 +0300
+++ gcc.libgomod/libgo/runtime/runtime.h	2021-06-19 20:51:46.959108269 +0300
@@ -503,7 +503,7 @@
 #define __go_getcontext(c)	getcontext(c)
 #define __go_setcontext(c)	setcontext(c)
 #define __go_makecontext(c, fn, sp, size) \
-	((c)->uc_stack.ss_sp = sp, (c)->uc_stack.ss_size = size, makecontext(c, fn, 0))
+	((c)->uc_stack.ss_sp = sp, (c)->uc_stack.ss_size = size, (c)->uc_mcontext.mc_len = sizeof((c)->uc_mcontext), makecontext(c, fn, 0))
 #endif
 
 // Symbols defined by the linker.
diff -NaurwB gcc.libgomod/libgo/runtime/yield.c libgo-821408fdd048faf3bf2627d0fe81a46d80ff3e5f/src/lib/gcc/libgo/runtime/yield.c
--- gcc.libgomod/libgo/runtime/yield.c	2021-04-08 14:56:30.101765214 +0300
+++ libgo-821408fdd048faf3bf2627d0fe81a46d80ff3e5f/src/lib/gcc/libgo/runtime/yield.c	2021-06-29 23:43:59.570834135 +0300
@@ -47,13 +47,10 @@
 }
 
 /* Sleep for some number of microseconds.  */
+extern void my_usleep(uint32 us);
 
 void
 runtime_usleep (uint32 us)
 {
-  struct timeval tv;
-
-  tv.tv_sec = us / 1000000;
-  tv.tv_usec = us % 1000000;
-  select (0, NULL, NULL, NULL, &tv);
+  my_usleep(us);
 }
diff -NaurwB gcc.libgomod/libgo/go/runtime/proc.go libgo-821408fdd048faf3bf2627d0fe81a46d80ff3e5f/src/lib/gcc/libgo/go/runtime/proc.go
--- gcc.libgomod/libgo/go/runtime/proc.go	2021-04-08 14:56:30.073764876 +0300
+++ libgo-821408fdd048faf3bf2627d0fe81a46d80ff3e5f/src/lib/gcc/libgo/go/runtime/proc.go	2021-07-14 00:48:49.209616164 +0300
@@ -47,6 +47,9 @@
 // C functions for thread and context management.
 func newosproc(*m)
 
+// C function to allocate space from area dedicated for thread stacks in genode
+func newmalloc() *m
+
 //go:noescape
 func malg(bool, bool, *unsafe.Pointer, *uintptr) *g
 
@@ -1351,7 +1373,11 @@
 		unlock(&sched.lock)
 	}
 
+	if GOOS == "inno" {
+		mp = newmalloc()
+	} else {
 	mp = new(m)
+	}
 	mp.mstartfn = fn
 	mcommoninit(mp)
 
